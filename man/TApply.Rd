% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TApply.R
\docType{methods}
\name{TApply}
\alias{TApply}
\alias{TApply,StQ,StQT-method}
\alias{TApply,data.table,StQT-method}
\title{Applies a transformation object on a StQ or data.table.}
\usage{
TApply(x, Tr)

\S4method{TApply}{data.table,StQT}(x, Tr)

\S4method{TApply}{StQ,StQT}(x, Tr)
}
\arguments{
\item{x}{Object of class \linkS4class{StQ} or \linkS4class{data.table} with data
to transform}

\item{Tr}{Object of class \linkS4class{StQT} with the transformation we are going
to apply.}
}
\value{
\linkS4class{StQ} or \linkS4class{data.table} respectively with transformed
data
}
\description{
\code{TApply} returns a transformed object according to the transformation rules.
}
\details{
There are three kinds of transformation rules:
internal functions, row insertion and column insertion.
\itemize{
\item{Internal functions}{FunDelRow, FunDelVar and FunAutoLink so far. The first one deletes
rows in domain. The second one deletes the variables specified in the output. The third one
copies the input variables from the table linking according to the expression in domain.}
\item{Row insertion}{Row are inserted. This kind of rule is applied when there exists an assignment in the output.
Unassigned variables are calculated according output = fun(input). Any variable included in by is copied into the new rows.}
\item{Column insertion}{Rows are calculated according output = fun (input)}
}
Parameter domain specifies the subset of the dataset where we are going to do the calculation.
Parameter by sets the variables where we are applying the rule by.
Parameter order orders the table, previously to apply the transformation.
Parameter key (irrelevant for data.table) sets which of the variables are qualifiers.
}
\examples{
require(data.table)
dt <- data.table(Region = c("1","2","3"), GDP = c(1.38,0.94,1.23))
dt
T1 <- NewStQT(data.frame(
  output = "Region='Total',GDP",
  fun = "sum",
  input = "GDP",
  stringsAsFactors = FALSE))
TApply(dt,T1)
require(StQ)
data(ExampleQ)
calibrate <- function(x,y) return(100*x/y)
rules <- data.frame(domain = c('','Total != 100',''),
                    output = c('Total','IASSLPCifraNeg','Total'),
                       fun = c('sum','calibrate','FunDelVar'),
                     input = c('IASSLPCifraNeg','IASSLPCifraNeg,Total',''),
                        by = c('NOrden','',''),
                       key = c('NOrden','',''),
                         stringsAsFactors = FALSE)
calibratepc <- NewStQT(rules)
dcast_StQ(TApply(ExampleQ,calibratepc[1]),"Total")[abs(Total-100)>1e-6] # In some cases percents do not sum up 100\%!
ExampleQ2 <- TApply(ExampleQ,calibratepc)
dcast_StQ(TApply(ExampleQ2,calibratepc[1]),"Total")[abs(Total-100)>1e-6] # After calibration they do!

}

